非打印字符
\cx  匹配由 x 指明的控制字符. x 值为 A-Z, a-z.
\f   匹配一个换页符. 等价于 \x0c 和 \cL
\n   换行符. \x0a  \cJ
\r   回车符  \x0d  \cM
\s   任何空白字符   [\f\n\r\t\v]
\S   任何非空白字符  [^\f\n\t\v]
\t   制表符  \x09  \cI
\v   垂直制表符  \x0b  \cK

特殊字符
^    匹配输入字符串的开始位置(方括号中表示不接受的字符集合的开始位置)(如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。)
$    匹配字符串结尾位置(若RegExp的对象设置了Multiline属性,则 $ 也匹配 \n 或 \r)
()   标记一个子表达式的开始和结束位置
[    标记一个中括号表达式的开始
{    标记限定符表达式的开始
*    匹配前面的子表达式零次或多次
+    匹配前面的子表达式一次或多次
.    匹配除 \n 之外的任何单字符
|    指明两项之间的一个选择
?    匹配前面的子表达式零次或一次,或指明一个非贪婪限定符
\    将下一个字符标记为特殊字符,或原义字符,或向后引用,或八进制转义符

限定符(表示一个给定组件必须要出现多少次才能满足匹配)
*     
+     
?
{n}       匹配确定的 n 次
{n,}      至少匹配 n 次
{n,m}     最少匹配 n 次, 最多匹配 m 次
ps: 1  n,m 均为非负整数
    2  *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。
    
定位符(描述字符串或单词的边界)
^
$
\b    匹配一个字边界,即字与空格间的位置
\B    非字边界匹配
ps: 不能将限定符与定位符一起使用.

反向引用
对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。
可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。

普通捕获组反向引用: \number , number为第几个捕获组
命名捕获组反向引用: \k<name> 或 \k'name'

/\b([a-z]+) \1\b/ig
([a-z]+) 匹配一个或多个字母
\1       匹配第一个匹配项(反向引用)
i        标记不区分大小写
g        全局查找尽可能多的匹配
总的来说,匹配这样的字符, 字符串s+空格+字符串s
例如: "Is is the cost of of gasoline going up up"
输出:  Is is,of of,up up

元字符(略去 特殊字符 与 限定符)
(pattern)    匹配 pattern 并获取这一匹配
(?:pattern)  匹配 pattern 但不获取这一匹配(不存储以后使用) 例: industr(?:y\lies) 比 industry|industries 更简略
(?=pattern)  正向肯定预查(非获取匹配),在任何匹配 pattern 字符串开始处匹配查找
(?!pattern)  正向否定预查(非获取匹配),在任何不匹配 pattern 字符串开始处匹配查找
(?<=pattern)  反向否定预查(非获取匹配)
(?<!pattern)  反向否定预查(非获取匹配)
x|y           匹配 x 或 y  
[a-z]         匹配指定范围内任意字符. 此例中匹配 a 到 z
[^a-z]        不匹配 a 到 z
\d            匹配一个数字字符    [0-9]
\D            匹配一个非数字字符  [^0-9]
\w            匹配字母,数字,下划线. 等价于[A-Za-z0-9_](待验证)
\W            匹配非字母,数字,下划线
\xn           匹配 n, n 为十六进制的转义值
\num          匹配一个正整数
\nm           标识一个八进制转义或一个向后引用


运算符优先级
转义符 -> 圆括号,方括号 -> 限定符 -> 定位点和序列(位置和顺序) -> 替换|


例: "1234567890".replace(/(\d)(?=(?:\d{3})+$)/g,'$1,')      -> 1,234,567,890
(?:\d{3})  三个连续数字,不做存储
(?=(?:\d{3})+$) 匹配三个数字一次或多次直到字符串结尾
(\d)(?=(?:\d{3})+$) 找出 x + xxx + xxx + ... 
这个正则表达式可以将整数添加千分位.

"1234567890.123".replace(/(\d)(?=(?:\d{3})+(?:\.|$))/g,'$1,')      -> 1,234,567,890.123
对小数也可以添加千分位. 将 \. 改为 (?:\.|$)).
不过也有问题,如果小数部分大于三位,也会加上逗号.















